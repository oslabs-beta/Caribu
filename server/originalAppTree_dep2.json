{"routers":[],"boundDispatchers":[{"path":"/user","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/user":{"methods":{"get":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next){\n  User.findById(req.payload.id).then(function(user){\n    if(!user){ return res.sendStatus(401); }\n\n    return res.json({user: user.toAuthJSON()});\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/user","bd":{},"methods":{"put":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"methods":{"put":true}}},"endpoints":{"/user":{"methods":{"put":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"methods":{"put":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next){\n  User.findById(req.payload.id).then(function(user){\n    if(!user){ return res.sendStatus(401); }\n\n    // only update fields that were actually passed...\n    if(typeof req.body.user.username !== 'undefined'){\n      user.username = req.body.user.username;\n    }\n    if(typeof req.body.user.email !== 'undefined'){\n      user.email = req.body.user.email;\n    }\n    if(typeof req.body.user.bio !== 'undefined'){\n      user.bio = req.body.user.bio;\n    }\n    if(typeof req.body.user.image !== 'undefined'){\n      user.image = req.body.user.image;\n    }\n    if(typeof req.body.user.password !== 'undefined'){\n      user.setPassword(req.body.user.password);\n    }\n\n    return user.save().then(function(){\n      return res.json({user: user.toAuthJSON()});\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/users/login","bd":{},"methods":{"post":true},"stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/users/login","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/users/login":{"methods":{"post":true},"path":"/users/login","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/users/login","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next){\n  if(!req.body.user.email){\n    return res.status(422).json({errors: {email: \"can't be blank\"}});\n  }\n\n  if(!req.body.user.password){\n    return res.status(422).json({errors: {password: \"can't be blank\"}});\n  }\n\n  passport.authenticate('local', {session: false}, function(err, user, info){\n    if(err){ return next(err); }\n\n    if(user){\n      user.token = user.generateJWT();\n      return res.json({user: user.toAuthJSON()});\n    } else {\n      return res.status(422).json(info);\n    }\n  })(req, res, next);\n}","nextFunc":null}}}}},{"path":"/users","bd":{},"methods":{"post":true},"stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/users","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/users":{"methods":{"post":true},"path":"/users","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/users","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next){\n  var user = new User();\n\n  user.username = req.body.user.username;\n  user.email = req.body.user.email;\n  user.setPassword(req.body.user.password);\n\n  user.save().then(function(){\n    return res.json({user: user.toAuthJSON()});\n  }).catch(next);\n}","nextFunc":null}}}}},{"path":"/:username","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[{"name":"username","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:username","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/:username":{"methods":{"get":true},"path":"/:username","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/:username","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next){\n  if(req.payload){\n    User.findById(req.payload.id).then(function(user){\n      if(!user){ return res.json({profile: req.profile.toProfileJSONFor(false)}); }\n\n      return res.json({profile: req.profile.toProfileJSONFor(user)});\n    });\n  } else {\n    return res.json({profile: req.profile.toProfileJSONFor(false)});\n  }\n}","nextFunc":null}}}}}},{"path":"/:username/follow","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[{"name":"username","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/:username/follow":{"methods":{"post":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next){\n  var profileId = req.profile._id;\n\n  User.findById(req.payload.id).then(function(user){\n    if (!user) { return res.sendStatus(401); }\n\n    return user.follow(profileId).then(function(){\n      return res.json({profile: req.profile.toProfileJSONFor(user)});\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:username/follow","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"username","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:username/follow":{"methods":{"delete":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next){\n  var profileId = req.profile._id;\n\n  User.findById(req.payload.id).then(function(user){\n    if (!user) { return res.sendStatus(401); }\n\n    return user.unfollow(profileId).then(function(){\n      return res.json({profile: req.profile.toProfileJSONFor(user)});\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/":{"methods":{"get":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  var query = {};\n  var limit = 20;\n  var offset = 0;\n\n  if(typeof req.query.limit !== 'undefined'){\n    limit = req.query.limit;\n  }\n\n  if(typeof req.query.offset !== 'undefined'){\n    offset = req.query.offset;\n  }\n\n  if( typeof req.query.tag !== 'undefined' ){\n    query.tagList = {\"$in\" : [req.query.tag]};\n  }\n\n  Promise.all([\n    req.query.author ? User.findOne({username: req.query.author}) : null,\n    req.query.favorited ? User.findOne({username: req.query.favorited}) : null\n  ]).then(function(results){\n    var author = results[0];\n    var favoriter = results[1];\n\n    if(author){\n      query.author = author._id;\n    }\n\n    if(favoriter){\n      query._id = {$in: favoriter.favorites};\n    } else if(req.query.favorited){\n      query._id = {$in: []};\n    }\n\n    return Promise.all([\n      Article.find(query)\n        .limit(Number(limit))\n        .skip(Number(offset))\n        .sort({createdAt: 'desc'})\n        .populate('author')\n        .exec(),\n      Article.count(query).exec(),\n      req.payload ? User.findById(req.payload.id) : null,\n    ]).then(function(results){\n      var articles = results[0];\n      var articlesCount = results[1];\n      var user = results[2];\n\n      return res.json({\n        articles: articles.map(function(article){\n          return article.toJSONFor(user);\n        }),\n        articlesCount: articlesCount\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/feed","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/feed","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/feed":{"methods":{"get":true},"path":"/feed","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/feed","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  var limit = 20;\n  var offset = 0;\n\n  if(typeof req.query.limit !== 'undefined'){\n    limit = req.query.limit;\n  }\n\n  if(typeof req.query.offset !== 'undefined'){\n    offset = req.query.offset;\n  }\n\n  User.findById(req.payload.id).then(function(user){\n    if (!user) { return res.sendStatus(401); }\n\n    Promise.all([\n      Article.find({ author: {$in: user.following}})\n        .limit(Number(limit))\n        .skip(Number(offset))\n        .populate('author')\n        .exec(),\n      Article.count({ author: {$in: user.following}})\n    ]).then(function(results){\n      var articles = results[0];\n      var articlesCount = results[1];\n\n      return res.json({\n        articles: articles.map(function(article){\n          return article.toJSONFor(user);\n        }),\n        articlesCount: articlesCount\n      });\n    }).catch(next);\n  });\n}","nextFunc":null}}}}}},{"path":"/","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/":{"methods":{"post":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  User.findById(req.payload.id).then(function(user){\n    if (!user) { return res.sendStatus(401); }\n\n    var article = new Article(req.body.article);\n\n    article.author = user;\n\n    return article.save().then(function(){\n      console.log(article.author);\n      return res.json({article: article.toJSONFor(user)});\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/:article":{"methods":{"get":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  Promise.all([\n    req.payload ? User.findById(req.payload.id) : null,\n    req.article.populate('author').execPopulate()\n  ]).then(function(results){\n    var user = results[0];\n\n    return res.json({article: req.article.toJSONFor(user)});\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article","bd":{},"methods":{"put":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"methods":{"put":true}}},"endpoints":{"/:article":{"methods":{"put":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"methods":{"put":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  User.findById(req.payload.id).then(function(user){\n    if(req.article.author._id.toString() === req.payload.id.toString()){\n      if(typeof req.body.article.title !== 'undefined'){\n        req.article.title = req.body.article.title;\n      }\n\n      if(typeof req.body.article.description !== 'undefined'){\n        req.article.description = req.body.article.description;\n      }\n\n      if(typeof req.body.article.body !== 'undefined'){\n        req.article.body = req.body.article.body;\n      }\n\n      if(typeof req.body.article.tagList !== 'undefined'){\n        req.article.tagList = req.body.article.tagList\n      }\n\n      req.article.save().then(function(article){\n        return res.json({article: article.toJSONFor(user)});\n      }).catch(next);\n    } else {\n      return res.sendStatus(403);\n    }\n  });\n}","nextFunc":null}}}}}},{"path":"/:article","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:article":{"methods":{"delete":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  User.findById(req.payload.id).then(function(user){\n    if (!user) { return res.sendStatus(401); }\n\n    if(req.article.author._id.toString() === req.payload.id.toString()){\n      return req.article.remove().then(function(){\n        return res.sendStatus(204);\n      });\n    } else {\n      return res.sendStatus(403);\n    }\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/favorite","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/:article/favorite":{"methods":{"post":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  var articleId = req.article._id;\n\n  User.findById(req.payload.id).then(function(user){\n    if (!user) { return res.sendStatus(401); }\n\n    return user.favorite(articleId).then(function(){\n      return req.article.updateFavoriteCount().then(function(article){\n        return res.json({article: article.toJSONFor(user)});\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/favorite","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:article/favorite":{"methods":{"delete":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  var articleId = req.article._id;\n\n  User.findById(req.payload.id).then(function (user){\n    if (!user) { return res.sendStatus(401); }\n\n    return user.unfavorite(articleId).then(function(){\n      return req.article.updateFavoriteCount().then(function(article){\n        return res.json({article: article.toJSONFor(user)});\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/comments","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/:article/comments":{"methods":{"get":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next){\n  Promise.resolve(req.payload ? User.findById(req.payload.id) : null).then(function(user){\n    return req.article.populate({\n      path: 'comments',\n      populate: {\n        path: 'author'\n      },\n      options: {\n        sort: {\n          createdAt: 'desc'\n        }\n      }\n    }).execPopulate().then(function(article) {\n      return res.json({comments: req.article.comments.map(function(comment){\n        return comment.toJSONFor(user);\n      })});\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/comments","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/:article/comments":{"methods":{"post":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  User.findById(req.payload.id).then(function(user){\n    if(!user){ return res.sendStatus(401); }\n\n    var comment = new Comment(req.body.comment);\n    comment.article = req.article;\n    comment.author = user;\n\n    return comment.save().then(function(){\n      req.article.comments.push(comment);\n\n      return req.article.save().then(function(article) {\n        res.json({comment: comment.toJSONFor(user)});\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/comments/:comment","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1},{"name":"comment","optional":false,"offset":26}],"regexp":{},"route":{"path":"/:article/comments/:comment","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:article/comments/:comment":{"methods":{"delete":true},"path":"/:article/comments/:comment","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:article/comments/:comment","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"<anonymous>","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function(req, res, next) {\n  if(req.comment.author.toString() === req.payload.id.toString()){\n    req.article.comments.remove(req.comment._id);\n    req.article.save()\n      .then(Comment.find({_id: req.comment._id}).remove().exec())\n      .then(function(){\n        res.sendStatus(204);\n      });\n  } else {\n    res.sendStatus(403);\n  }\n}","nextFunc":null}}}}}},{"path":"/","bd":{},"methods":{"get":true},"stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/":{"methods":{"get":true},"path":"/","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/","stack":[{"name":"<anonymous>","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n  Article.find().distinct('tagList').then(function(tags){\n    return res.json({tags: tags});\n  }).catch(next);\n}","nextFunc":null}}}}}]}