{"routers":[],"boundDispatchers":[{"path":"/user","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART216_CBUEND408_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART216_CBUEND408_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/user":{"methods":{"get":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART216_CBUEND408_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART216_CBUEND408_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART216_CBUEND408_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(req, res, next) {\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART279_CBUEND392_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    return res.json({ user: user.toAuthJSON() });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/user","bd":{},"methods":{"put":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART447_CBUEND1249_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"put"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART447_CBUEND1249_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"put"}],"methods":{"put":true}}},"endpoints":{"/user":{"methods":{"put":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART447_CBUEND1249_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"methods":{"put":true},"path":"/user","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART447_CBUEND1249_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART447_CBUEND1249_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(req, res, next) {\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART510_CBUEND1233_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    // only update fields that were actually passed...\n    if (typeof req.body.user.username !== 'undefined') {\n      user.username = req.body.user.username;\n    }\n    if (typeof req.body.user.email !== 'undefined') {\n      user.email = req.body.user.email;\n    }\n    if (typeof req.body.user.bio !== 'undefined') {\n      user.bio = req.body.user.bio;\n    }\n    if (typeof req.body.user.image !== 'undefined') {\n      user.image = req.body.user.image;\n    }\n    if (typeof req.body.user.password !== 'undefined') {\n      user.setPassword(req.body.user.password);\n    }\n\n    return user.save().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1160_CBUEND1227_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js() {\n      return res.json({ user: user.toAuthJSON() });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/users/login","bd":{},"methods":{"post":true},"stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1281_CBUEND1817_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/users/login","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1281_CBUEND1817_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/users/login":{"methods":{"post":true},"path":"/users/login","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1281_CBUEND1817_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/users/login","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1281_CBUEND1817_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1281_CBUEND1817_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(req, res, next) {\n  if (!req.body.user.email) {\n    return res.status(422).json({ errors: { email: \"can't be blank\" } });\n  }\n\n  if (!req.body.user.password) {\n    return res.status(422).json({ errors: { password: \"can't be blank\" } });\n  }\n\n  passport.authenticate('local', { session: false }, function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1570_CBUEND1797_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(err, user, info) {\n    if (err) {return next(err);}\n\n    if (user) {\n      user.token = user.generateJWT();\n      return res.json({ user: user.toAuthJSON() });\n    } else {\n      return res.status(422).json(info);\n    }\n  })(req, res, next);\n}","nextFunc":null}}}}},{"path":"/users","bd":{},"methods":{"post":true},"stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1843_CBUEND2116_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/users","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1843_CBUEND2116_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/users":{"methods":{"post":true},"path":"/users","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1843_CBUEND2116_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/users","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1843_CBUEND2116_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1843_CBUEND2116_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js(req, res, next) {\n  var user = new User();\n\n  user.username = req.body.user.username;\n  user.email = req.body.user.email;\n  user.setPassword(req.body.user.password);\n\n  user.save().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2037_CBUEND2100_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$users_js() {\n    return res.json({ user: user.toAuthJSON() });\n  }).catch(next);\n}","nextFunc":null}}}}},{"path":"/:username","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART470_CBUEND818_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[{"name":"username","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:username","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART470_CBUEND818_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/:username":{"methods":{"get":true},"path":"/:username","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART470_CBUEND818_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/:username","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART470_CBUEND818_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART470_CBUEND818_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js(req, res, next) {\n  if (req.payload) {\n    User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART554_CBUEND730_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js(user) {\n      if (!user) {return res.json({ profile: req.profile.toProfileJSONFor(false) });}\n\n      return res.json({ profile: req.profile.toProfileJSONFor(user) });\n    });\n  } else {\n    return res.json({ profile: req.profile.toProfileJSONFor(false) });\n  }\n}","nextFunc":null}}}}}},{"path":"/:username/follow","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART870_CBUEND1181_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[{"name":"username","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART870_CBUEND1181_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/:username/follow":{"methods":{"post":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART870_CBUEND1181_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART870_CBUEND1181_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART870_CBUEND1181_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js(req, res, next) {\n  var profileId = req.profile._id;\n\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART969_CBUEND1165_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    return user.follow(profileId).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1072_CBUEND1159_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js() {\n      return res.json({ profile: req.profile.toProfileJSONFor(user) });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:username/follow","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1235_CBUEND1548_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"username","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1235_CBUEND1548_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:username/follow":{"methods":{"delete":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1235_CBUEND1548_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:username/follow","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1235_CBUEND1548_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1235_CBUEND1548_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js(req, res, next) {\n  var profileId = req.profile._id;\n\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1334_CBUEND1532_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    return user.unfollow(profileId).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1439_CBUEND1526_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$profiles_js() {\n      return res.json({ profile: req.profile.toProfileJSONFor(user) });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART807_CBUEND2221_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART807_CBUEND2221_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/":{"methods":{"get":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART807_CBUEND2221_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART807_CBUEND2221_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART807_CBUEND2221_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  var query = {};\n  var limit = 20;\n  var offset = 0;\n\n  if (typeof req.query.limit !== 'undefined') {\n    limit = req.query.limit;\n  }\n\n  if (typeof req.query.offset !== 'undefined') {\n    offset = req.query.offset;\n  }\n\n  if (typeof req.query.tag !== 'undefined') {\n    query.tagList = { \"$in\": [req.query.tag] };\n  }\n\n  Promise.all([\n  req.query.author ? User.findOne({ username: req.query.author }) : null,\n  req.query.favorited ? User.findOne({ username: req.query.favorited }) : null]).\n  then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1329_CBUEND2205_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(results) {\n    var author = results[0];\n    var favoriter = results[1];\n\n    if (author) {\n      query.author = author._id;\n    }\n\n    if (favoriter) {\n      query._id = { $in: favoriter.favorites };\n    } else if (req.query.favorited) {\n      query._id = { $in: [] };\n    }\n\n    return Promise.all([\n    Article.find(query).\n    limit(Number(limit)).\n    skip(Number(offset)).\n    sort({ createdAt: 'desc' }).\n    populate('author').\n    exec(),\n    Article.count(query).exec(),\n    req.payload ? User.findById(req.payload.id) : null]).\n    then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART1899_CBUEND2199_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(results) {\n      var articles = results[0];\n      var articlesCount = results[1];\n      var user = results[2];\n\n      return res.json({\n        articles: articles.map(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2074_CBUEND2144_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n          return article.toJSONFor(user);\n        }),\n        articlesCount: articlesCount\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/feed","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2260_CBUEND3123_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/feed","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2260_CBUEND3123_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/feed":{"methods":{"get":true},"path":"/feed","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2260_CBUEND3123_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/feed","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2260_CBUEND3123_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2260_CBUEND3123_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  var limit = 20;\n  var offset = 0;\n\n  if (typeof req.query.limit !== 'undefined') {\n    limit = req.query.limit;\n  }\n\n  if (typeof req.query.offset !== 'undefined') {\n    offset = req.query.offset;\n  }\n\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2524_CBUEND3119_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    Promise.all([\n    Article.find({ author: { $in: user.following } }).\n    limit(Number(limit)).\n    skip(Number(offset)).\n    populate('author').\n    exec(),\n    Article.count({ author: { $in: user.following } })]).\n    then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2830_CBUEND3101_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(results) {\n      var articles = results[0];\n      var articlesCount = results[1];\n\n      return res.json({\n        articles: articles.map(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART2976_CBUEND3046_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n          return article.toJSONFor(user);\n        }),\n        articlesCount: articlesCount\n      });\n    }).catch(next);\n  });\n}","nextFunc":null}}}}}},{"path":"/","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3159_CBUEND3529_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3159_CBUEND3529_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/":{"methods":{"post":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3159_CBUEND3529_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3159_CBUEND3529_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3159_CBUEND3529_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3223_CBUEND3513_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    var article = new Article(req.body.article);\n\n    article.author = user;\n\n    return article.save().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3396_CBUEND3507_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js() {\n      console.log(article.author);\n      return res.json({ article: article.toJSONFor(user) });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3592_CBUEND3878_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3592_CBUEND3878_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/:article":{"methods":{"get":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3592_CBUEND3878_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3592_CBUEND3878_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3592_CBUEND3878_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  Promise.all([\n  req.payload ? User.findById(req.payload.id) : null,\n  req.article.populate('author').execPopulate()]).\n  then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3751_CBUEND3862_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(results) {\n    var user = results[0];\n\n    return res.json({ article: req.article.toJSONFor(user) });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article","bd":{},"methods":{"put":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3939_CBUEND4776_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"put"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3939_CBUEND4776_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"put"}],"methods":{"put":true}}},"endpoints":{"/:article":{"methods":{"put":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3939_CBUEND4776_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"methods":{"put":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"put"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3939_CBUEND4776_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"put"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART3939_CBUEND4776_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4003_CBUEND4772_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (req.article.author._id.toString() === req.payload.id.toString()) {\n      if (typeof req.body.article.title !== 'undefined') {\n        req.article.title = req.body.article.title;\n      }\n\n      if (typeof req.body.article.description !== 'undefined') {\n        req.article.description = req.body.article.description;\n      }\n\n      if (typeof req.body.article.body !== 'undefined') {\n        req.article.body = req.body.article.body;\n      }\n\n      if (typeof req.body.article.tagList !== 'undefined') {\n        req.article.tagList = req.body.article.tagList;\n      }\n\n      req.article.save().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4614_CBUEND4701_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n        return res.json({ article: article.toJSONFor(user) });\n      }).catch(next);\n    } else {\n      return res.sendStatus(403);\n    }\n  });\n}","nextFunc":null}}}}}},{"path":"/:article","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4840_CBUEND5210_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4840_CBUEND5210_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:article":{"methods":{"delete":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4840_CBUEND5210_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:article","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4840_CBUEND5210_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4840_CBUEND5210_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART4904_CBUEND5194_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    if (req.article.author._id.toString() === req.payload.id.toString()) {\n      return req.article.remove().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5080_CBUEND5135_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js() {\n        return res.sendStatus(204);\n      });\n    } else {\n      return res.sendStatus(403);\n    }\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/favorite","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5286_CBUEND5672_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5286_CBUEND5672_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/:article/favorite":{"methods":{"post":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5286_CBUEND5672_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5286_CBUEND5672_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5286_CBUEND5672_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  var articleId = req.article._id;\n\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5386_CBUEND5656_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    return user.favorite(articleId).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5491_CBUEND5650_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js() {\n      return req.article.updateFavoriteCount().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5555_CBUEND5642_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n        return res.json({ article: article.toJSONFor(user) });\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/favorite","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5752_CBUEND6141_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5752_CBUEND6141_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:article/favorite":{"methods":{"delete":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5752_CBUEND6141_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:article/favorite","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5752_CBUEND6141_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5752_CBUEND6141_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  var articleId = req.article._id;\n\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5852_CBUEND6125_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    return user.unfavorite(articleId).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART5960_CBUEND6119_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js() {\n      return req.article.updateFavoriteCount().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6024_CBUEND6111_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n        return res.json({ article: article.toJSONFor(user) });\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/comments","bd":{},"methods":{"get":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6225_CBUEND6732_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6225_CBUEND6732_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/:article/comments":{"methods":{"get":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6225_CBUEND6732_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"get"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6225_CBUEND6732_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6225_CBUEND6732_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  Promise.resolve(req.payload ? User.findById(req.payload.id) : null).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6326_CBUEND6716_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    return req.article.populate({\n      path: 'comments',\n      populate: {\n        path: 'author'\n      },\n      options: {\n        sort: {\n          createdAt: 'desc'\n        }\n      }\n    }).execPopulate().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6556_CBUEND6710_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n      return res.json({ comments: req.article.comments.map(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6634_CBUEND6700_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(comment) {\n          return comment.toJSONFor(user);\n        }) });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/comments","bd":{},"methods":{"post":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6809_CBUEND7281_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1}],"regexp":{},"route":{"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6809_CBUEND7281_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"methods":{"post":true}}},"endpoints":{"/:article/comments":{"methods":{"post":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6809_CBUEND7281_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"methods":{"post":true},"path":"/:article/comments","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"post"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6809_CBUEND7281_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"post"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6809_CBUEND7281_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  User.findById(req.payload.id).then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART6873_CBUEND7265_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(user) {\n    if (!user) {return res.sendStatus(401);}\n\n    var comment = new Comment(req.body.comment);\n    comment.article = req.article;\n    comment.author = user;\n\n    return comment.save().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7078_CBUEND7259_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js() {\n      req.article.comments.push(comment);\n\n      return req.article.save().then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7170_CBUEND7251_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(article) {\n        res.json({ comment: comment.toJSONFor(user) });\n      });\n    });\n  }).catch(next);\n}","nextFunc":null}}}}}},{"path":"/:article/comments/:comment","bd":{},"methods":{"delete":true},"stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7345_CBUEND7682_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"router":{"name":"bound dispatch","keys":[{"name":"article","optional":false,"offset":1},{"name":"comment","optional":false,"offset":26}],"regexp":{},"route":{"path":"/:article/comments/:comment","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7345_CBUEND7682_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"methods":{"delete":true}}},"endpoints":{"/:article/comments/:comment":{"methods":{"delete":true},"path":"/:article/comments/:comment","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7345_CBUEND7682_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"methods":{"delete":true},"path":"/:article/comments/:comment","stack":[{"name":"middleware","keys":[],"regexp":{},"method":"delete"},{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7345_CBUEND7682_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js","keys":[],"regexp":{},"method":"delete"}],"middlewareChain":{"funcString":"function(req, res, next) {\n    var token;\n\n    if (req.method === 'OPTIONS' && req.headers.hasOwnProperty('access-control-request-headers')) {\n      var hasAuthInAccessControl = !!~req.headers['access-control-request-headers']\n                                    .split(',').map(function (header) {\n                                      return header.trim();\n                                    }).indexOf('authorization');\n\n      if (hasAuthInAccessControl) {\n        return next();\n      }\n    }\n\n    if (typeof options.skip !== 'undefined') {\n      console.warn('WARN: express-jwt: options.skip is deprecated');\n      console.warn('WARN: use app.use(jwt(options).unless({path: \\'/x\\'}))');\n      if (options.skip.indexOf(req.url) > -1) {\n        return next();\n      }\n    }\n\n    if (options.getToken && typeof options.getToken === 'function') {\n      try {\n        token = options.getToken(req);\n      } catch (e) {\n        return next(e);\n      }\n    } else if (req.headers && req.headers.authorization) {\n      var parts = req.headers.authorization.split(' ');\n      if (parts.length == 2) {\n        var scheme = parts[0];\n        var credentials = parts[1];\n\n        if (/^Bearer$/i.test(scheme)) {\n          token = credentials;\n        } else {\n          return next(new UnauthorizedError('credentials_bad_scheme', { message: 'Format is Authorization: Bearer [token]' }));\n        }\n      } else {\n        return next(new UnauthorizedError('credentials_bad_format', { message: 'Format is Authorization: Bearer [token]' }));\n      }\n    }\n\n    if (!token) {\n      if (credentialsRequired) {\n        return next(new UnauthorizedError('credentials_required', { message: 'No authorization token was found' }));\n      } else {\n        return next();\n      }\n    }\n\n    var dtoken = jwt.decode(token, { complete: true }) || {};\n\n    async.waterfall([\n      function getSecret(callback){\n        var arity = secretCallback.length;\n        if (arity == 4) {\n          secretCallback(req, dtoken.header, dtoken.payload, callback);\n        } else { // arity == 3\n          secretCallback(req, dtoken.payload, callback);\n        }\n      },\n      function verifyToken(secret, callback) {\n        jwt.verify(token, secret, options, function(err, decoded) {\n          if (err && credentialsRequired) {\n            callback(new UnauthorizedError('invalid_token', err));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      },\n      function checkRevoked(decoded, callback) {\n        isRevokedCallback(req, dtoken.payload, function (err, revoked) {\n          if (err) {\n            callback(err);\n          }\n          else if (revoked) {\n            callback(new UnauthorizedError('revoked_token', {message: 'The token has been revoked.'}));\n          } else {\n            callback(null, decoded);\n          }\n        });\n      }\n\n    ], function (err, result){\n      if (err) { return next(err); }\n      _.set(req, _requestProperty, result);\n      next();\n    });\n  }","nextFunc":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7345_CBUEND7682_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js(req, res, next) {\n  if (req.comment.author.toString() === req.payload.id.toString()) {\n    req.article.comments.remove(req.comment._id);\n    req.article.save().\n    then(Comment.find({ _id: req.comment._id }).remove().exec()).\n    then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART7590_CBUEND7638_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$articles_js() {\n      res.sendStatus(204);\n    });\n  } else {\n    res.sendStatus(403);\n  }\n}","nextFunc":null}}}}}},{"path":"/","bd":{},"methods":{"get":true},"stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART161_CBUEND300_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$tags_js","keys":[],"regexp":{},"method":"get"}],"router":{"name":"bound dispatch","keys":[],"regexp":{},"route":{"path":"/","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART161_CBUEND300_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$tags_js","keys":[],"regexp":{},"method":"get"}],"methods":{"get":true}}},"endpoints":{"/":{"methods":{"get":true},"path":"/","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART161_CBUEND300_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$tags_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"methods":{"get":true},"path":"/","stack":[{"name":"CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART161_CBUEND300_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$tags_js","keys":[],"regexp":{},"method":"get"}],"middlewareChain":{"funcString":"function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART161_CBUEND300_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$tags_js(req, res, next) {\n  Article.find().distinct('tagList').then(function CBUNAME_ANONYMOUS_CBUTYPE_FUNCTIONEXPRESSION_CARIBU_CBUSTART230_CBUEND284_CBUPATHUsers$morry$git$Caribu$server$process$copiedServer$routes$api$tags_js(tags) {\n    return res.json({ tags: tags });\n  }).catch(next);\n}","nextFunc":null}}}}}]}